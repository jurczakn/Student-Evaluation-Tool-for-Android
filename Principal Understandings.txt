Performance
All of the attributes on the datastore are indexed, with the exception of the foreign key lists (course list for students and question list for courses) as they are not supported.  Still, the front-end app only makes get request to retrieve entire lists, or always access entities by their key for maximum efficiency.  All of the rest of the computation is done on the front-end.  The computations are small and could easily be done on any android device.  This frees up the back-end to carry out more requests.  
The only exception is when enforcing unique attributes for entities, such as usernames.  This is done on the back-end.  It will improve the performance, because it requires searching through all of the entities in the database, not just those in the entity group.  This would be too large of a request, to get all of the teachers or students stored in the entire database.  Also, it would not be good practice to give any user access to every username in the system.
All of the requests are done asynchronously.  There are some cases where several lists are being requested at the same time.  For example, when a student views their courses tab, they are given a list of all of their courses to choose from as well as a list of all courses from their school to register for.  In many cases, the list of courses the student is already enrolled in is much smaller than the list of all courses, and will return much faster.  In that case, the student¡¯s courses will display first, so they will not have to wait for the full list to return, to continue on with their work.
Sharding is one thing that I did not do, but could have to increase the performance.  It would have been useful if the app was actually being used.  With only myself testing the app, I am not able to get the necessary data though shard counting.  I would have guessed that the courses would be updated most often, as questions would be added to courses quicker than peoples personal information would change.  But if I were to use this in reality, it would most likely have to be monitored and changed.  I would assume that students would be accessed most often at the beginning of the semester, adding classes during registration, but be relatively untouched during the rest of the year.  
Security
For my app, I set up my own login system, and it fails on most of even the most basic expectations on security.  First, the passwords are never encrypted or hashed, either when they are sent or stored.  They are, in fact, viewable by everyone through the API.  This normally should never be the case.  In my implementation, the login is more useful in letting the user access they want to then stopping anyone else from accessing that information.  
The API uses no Authorization or Authentication.  Anyone can access any part of the API without a problem.  This is, of course, very poor design, as it would be very easy for someone to maliciously take, change, or even delete someone else¡¯s information.  It is even possible to do this by accident.  The only safe guard against this is that only one entity can be deleted per second for each school, so someone cannot accidentally delete a large amount of information from the server.  
Having steps to ask for Authentication to access parts of the API is necessary if this were to work in the real world.  It would also have to ensure that only teachers, then, are able to change courses and other students. 
The mobile front-end is not much better than the cloud back-end in terms of security.  It does ask the user to Authenticate themselves when first starting the program, but the passwords are sent in plain text strings.  In fact, the passwords are stored as plain text strings, which is not good practice.  If the user information was compromised, it would be readily available to whomever took it.  The problem is that anyone can create a teacher account for any school.  So if someone wanted to access information for another school, they need only create an account, which there is nothing stopping them.  There should probably be some unique, one-time-use code required to create a teacher account that is tied to a specific school.  That way the schools can be given this list of codes and can regulate who can create accounts.  Or, an admin account could be created for each school, requiring the implementation of a new user type.  The admin account would be the only way to create a new teacher account.  
The only way that the front-end enforces Authorization is by only giving the user options that they should be allowed to.  Students are only allowed to see courses in their own school, and can only edit their own profile.  Teachers are only allowed to create, view, edit, and delete courses for their school.  They are also only allowed to access their own teacher profiles.  This is not a good way to enforce Authorization.  Just because I programmed the front-end to only give the user options they should have, does not mean that it is not possible for a malicious user to find a way to access something they should not. 
The front-end should check for Authorization when doing every transaction.  It should ensure that the user logged in is the same as the profile being changed.  Or for teachers, that the teacher logged in belongs to the same school that the course belongs to.  In addition, if the user is about to do something that could significantly affect the system for other users, the app should ask the user to Re-Authenticate.  If there was an issue with someone¡¯s¡¯ account being compromised while they were signed-in, this would at least minimize and contain the impact.

Portability
The native app uses a minimum SDK version 11 of android (Android 3.0 or Honeycomb).  This is the lowest that I could allow, because of the use of the ActionBar class.  It is necessary to allowed for the tabbed view in both the student and teacher profile views.  Even so, this will still support the majority, over 95%, of the total user base of the Google Play Store.  That being said, I have emulated it on the minimum version of android, but have only been able to test it on one piece of hardware that runs android 5.0.  But if the Google API is to be trusted, then I believe that this app is portable between basically all android devices out there.  All of the activities use a relative layout and do not work in definite pixel sizes.  So it should show up properly on any size screens.  I have emulated it on average size smart phone and tablets, and it was displayed properly.
Portability between systems is another story.  This is a native app, so it will only run on android.  From the little experience I have with Windows Phone from this course, I believe that the front-end would have to be completely built from the ground up to be ported to Windows Phone, so in that regard it fails in portability.  Although I have never worked with it, I believe the same would be true for IOS.  This is more of a reality of having systems that are written in different languages.  The only way this could really be fixed is by making it a web app instead of a native app.  Regardless, this program uses a staggering amount of the Google Android API, so even if there was another system that ran of java and xml that I would like to port the app to, it would still need to be basically rewritten entirely again.
The better practice would be to take away all of the uses of the Android API and isolate them.  This is difficult, as each Activity in the android API must be its own class, and are best to be separated.  Even so, most of the computation for the program is independent of android.  It would have been possible to, at the very least, separate the code that does the computation, and even the http requests, into their own files, so at least something could be reused.
The cloud back-end is also completely dependent on the Google API.  It is basically only used to access the datastore, which is entirely designed to work for the Google NoDatabase.  If I were to take the back-end and move it to another system, all of the code would have to be rewritten, and the database itself would have to be completely redesigned.  It was originally designed to take full advantage of the Google App Engine datastore¡¯s hierarchy system and will not function without a similar system.  This means that even the information already stored on the servers would not be useful.  The entities would have to be redesigned and then the old data would have to be converted to work in a new system.
It would have better to have designed the database independently of the Google App Engine, and then allow it to use its features when implemented.  For example, instead of having teachers and students only being decedents of their schools, they should have also held a foreign key of their parent schools.  That way, if the database had to be moved, the teachers and students would have a record of the school they belong to, so they could just be carried over to a new system without losing this connection.  They could even be moved to a relational database, and then queries could be made joining them with their school.
Reliability
I did not put in any work to increase reliability in the cloud back-end of this project.  Google App Engine claims to have a 99.95% uptime.  It does this by replicating the datastore to multiple location across large distances.  This could be achieved by any Google App Engine project by migrating data to the High Replication Datastore.  This is obviously not necessary for this project, but if it were necessary in real application, it should be done.  
Another way to ensure the reliability of the cloud beyond what Google provides would be to create a backup on a separate cloud provider, but as explained above, this would take a substantial amount of work, as the datastore is not portable.  But, this would ensure that if the Google App Engine were to go down, you could keep the app up regardless. 
The front-end is only as reliable as the server and the internet connection.  The project ceases to work if the connection with the server is not available.  To fix this, the front-end could store information on the phone for the users¡¯ courses and profile.  I kept this out in the current version to keep everything strongly consistent.  Because many things, such as courses and questions, are accessible by several users, it would be very possible for more than one person to edit the same object while offline and create a problem.  Although, it would be possible to store information locally for users to view and not edit, achieving maximum reliability.  
Interoperability
The cloud back-end follows the standard of a resource based API.  It creates an uri for each entity, and uses all four of the major HTTP verbs.  They all work as expected and return what would be expected.  This could have been taken a step further by making the API fully RESTful.  This would have taken quite a bit more work, but would have helped for its interoperability.  
The front-end follows almost all of the standards for an android app.  Each page is its own activity.  Each activity has a related xml layout to display the ui.  Resources are stored in their own files and accessed only when needed, and activities talk to each other through intents.  
There was really only one instance where I deviated from the android standard.  That was when dealing with the tabbed activities for the student and teacher profiles and loading the fragments.  The standard is to use a FragmentPagerAdapter object to talk between your fragments and your activity with a ViewPager.  If given more time, I may have attempted to get this to work, but with the time constraint, I opted just to get the program to work by calling the fragments directly from the activity.  Using the FragmentPagerAdapter made accomplishing the task of adding tabs exponentially more difficult with no real benefit.  After some struggling and not much time researching, it turns out that this is an issue that many programmers have with the Android API.  It may have been better practice to have followed the standard, but this workaround seems to be quicker and more stable than the standard, so I made the decision not to follow it.
Usability
One of the first issues I had with usability was navigating the user through the somewhat complex issue of logging in.  To me, the process makes sense, but that is only because I designed the system.  It is made to mimic real life.  But I understand that to the user it may not be as intuitive.  I wanted to give the user as few options as possible, while still making the process quick for someone who already knows how to use the system.
When first starting the app, it only gives the user the option to select their school.  It is selected once, and the user is never prompted with this screen again, unless they logout.  This information is vital, as it is involved in many aspects of the system, but the user should not have to worry about it, so they are asked once and it is never brought up after that.
On the next screen the user has two text boxes, hinting them to put in a username and password, radio button for either a student or teacher, and two buttons.  The use of the terms username and password should immediately inform the user that this is a login page.  The radio button are placed directly under the text boxes to show they are related, and used for login.  If they user knows what they are doing, they can immediately login and continue to their profile.  So at that point, the user has gone through two screens and is at their profile. 
Otherwise, the user only has one other option, to create an account, as described in the only other button.  The one thing that I felt was not so self-explanatory, was whether the user wanted to create a student or teacher account.  It must be decided first, because different information is needed based on the type.  I opted to have the radio buttons above associate with this, but in case the user did not know, I included a large title on the next page that either reads ¡°Create Teacher¡± or ¡°Create Student¡± that is hard to miss.  If they are in the wrong place, they need simply hit the back button, and switch the only option on the page between student and teacher.
I still feel this is the most confusing part of the UI.  All of the people I let test the app that are used to using android were able to figure it out on the first go, but many of the people who have limited experience with android were confused at this step.  I could not think of a way to alieve this without either over complicating the app, or slowing it down for users who are trying to get through quickly.  
One other think about the create account page is that it could fail if the username is taken.  If this occurs, it will occur the first time the user starts the app, so I wanted it to fail as gracefully as possible.  The screen does not move if this happens.  A status message shows up at the bottom of the screen, and nothing else is altered.  All the user needs to do is enter a new username and submit a second time.  
After logging in, the user is brought to the profile page.  It is where the main work is done and is the most complicated.  To account for this, I split it into three tabs: profile, courses, and edit.  This way, all three pages are available from the start, they have a very simple UI, instead of having one cluttered page, but the user does not have to keep navigating between three separate pages.
All of the http requests are done asynchronously to improve performance, but this also helps with responsiveness, I gave the example before where a student can continue to one of their courses even before the full list of offered courses is loaded, even though they are on the same page.  As an added not for the usability on that page, if either the student has no courses enrolled, the list does not display and neither does the button associated.  The same is true for the list of courses available is the student is already enrolled in all the courses.  The list does not display and neither does the button to register.
Every page that does an http request also has a hidden status message.  When the page goes through and ends each phase of the request, the status is updated.  In most cases, it occurs so quickly that the user will never see it, but the result is also displayed after each request.  If the user was requesting information, it is displayed.  If they were trying to change something in the database, the result is displayed, and if anything goes wrong for either, the error is displayed in human readable text, so the user is never stuck wondering what happened.
The student and teacher profile page was loading slowly on the emulator.  I assume it was because it consists of three pages being loaded because of the tabbed view.  Because of this, I added a message to the login page, ¡°Login successful¡±, to persist after the user logged in, until the profile page is loaded.  When testing it on hardware I did not see the same delay, but kept it just in case some devices load slower.   
One problem with displaying results was when deleting an account.  I would display the result of the delete, and if successful, bring the user back to the front page.  The problem was, the delete command would usually execute so fast, the user would be brought back to the front page immediately without being able to read the result.  So I used a handler to delay the redirect to the front page.  The program now gives the user enough time to view the response.
I then took the same idea for taking a course.  The course asks several questions in a row before displaying the final results, but I wanted the user to see the results of each individual question first.  I had contemplated having the user submit the answer for a question, then being given the result, and then being prompted to click to continue.  This worked well when I was first testing it, but then when adding more questions, realized that it starts to get tiresome clicking over and over, especially when you have already seen that question before.  
Instead, now the user submits their answer, then they are shown the result.  The program holds on for a few seconds, and then automatically loads the next question on its own. This ended up working much nicer and feeling more natural.  Even though it ended up taking more time, it was more passive so it felt like it went faster.  I knew that I wanted to go on to the next question when I hit the submit button, but also that I want to see the result of the last question.  Now the user pressed one button, and it does everything they want.
 
